// Code generated by impgen. DO NOT EDIT.

package filesystem_test

import _imptest "github.com/toejough/imptest/imptest"
import _testing "testing"
import _time "time"
import filesystem "github.com/joe/copy-files/pkg/filesystem"

// FileScannerImp is the test controller for mocking the interface.
// Create with NewFileScannerImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewFileScannerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type FileScannerImp struct {
	*_imptest.Controller[*FileScannerImpCall]
	Mock         *FileScannerImpMock
	ExpectCallIs *FileScannerImpExpectCallIs
	currentCall  *FileScannerImpCall
}

// NewFileScannerImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewFileScannerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewFileScannerImp(t *_testing.T) *FileScannerImp {
	imp := &FileScannerImp{
		Controller: _imptest.NewController[*FileScannerImpCall](t),
	}
	imp.Mock = &FileScannerImpMock{imp: imp}
	imp.ExpectCallIs = &FileScannerImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *FileScannerImp) GetCurrentCall() *FileScannerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *FileScannerImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a FileScannerImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *FileScannerImp) Within(d _time.Duration) *FileScannerImpTimed {
	return &FileScannerImpTimed{
		ExpectCallIs: &FileScannerImpExpectCallIs{imp: i, timeout: d},
	}
}

// FileScannerImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type FileScannerImpCall struct {
	next *FileScannerImpNextCall
	err  *FileScannerImpErrCall
}

// AsErr returns the call cast to FileScannerImpErrCall for accessing call details.
// Returns nil if the call was not to Err.
func (c *FileScannerImpCall) AsErr() *FileScannerImpErrCall {
	return c.err
}

// AsNext returns the call cast to FileScannerImpNextCall for accessing call details.
// Returns nil if the call was not to Next.
func (c *FileScannerImpCall) AsNext() *FileScannerImpNextCall {
	return c.next
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *FileScannerImpCall) Done() bool {
	if c.next != nil {
		return c.next.done
	}
	if c.err != nil {
		return c.err.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *FileScannerImpCall) Name() string {
	if c.next != nil {
		return "Next"
	}
	if c.err != nil {
		return "Err"
	}
	return ""
}

// FileScannerImpErrBuilder provides a fluent API for setting expectations on Err calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileScannerImpErrBuilder struct {
	imp     *FileScannerImp
	timeout _time.Duration
}

// InjectPanic waits for a Err call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileScannerImpErrBuilder) InjectPanic(msg any) *FileScannerImpErrCall {
	validator := func(callToCheck *FileScannerImpCall) bool {
		return callToCheck.Name() == "Err"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsErr()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Err call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileScannerImpErrBuilder) InjectResult(result error) *FileScannerImpErrCall {
	validator := func(callToCheck *FileScannerImpCall) bool {
		return callToCheck.Name() == "Err"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsErr()
	methodCall.InjectResult(result)
	return methodCall
}

// FileScannerImpErrCall represents a captured call to the Err method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileScannerImpErrCall struct {
	responseChan chan FileScannerImpErrCallResponse
	done         bool
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileScannerImpErrCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileScannerImpErrCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileScannerImpErrCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileScannerImpErrCallResponse{Type: "return", Result0: result}
}

// FileScannerImpErrCallResponse holds the response configuration for the Err method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileScannerImpErrCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileScannerImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent FileScannerImp to configure timeouts.
type FileScannerImpExpectCallIs struct {
	imp     *FileScannerImp
	timeout _time.Duration
}

// Err returns a builder for setting expectations on Err method calls.
func (e *FileScannerImpExpectCallIs) Err() *FileScannerImpErrBuilder {
	return &FileScannerImpErrBuilder{imp: e.imp, timeout: e.timeout}
}

// Next returns a builder for setting expectations on Next method calls.
func (e *FileScannerImpExpectCallIs) Next() *FileScannerImpNextBuilder {
	return &FileScannerImpNextBuilder{imp: e.imp, timeout: e.timeout}
}

// FileScannerImpMock provides the mock implementation of the interface.
// Pass FileScannerImpMock to code under test that expects the interface implementation.
// Use the parent FileScannerImp controller to set expectations and inject responses.
type FileScannerImpMock struct {
	imp *FileScannerImp
}

// Err implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileScannerImpMock) Err() error {
	responseChan := make(chan FileScannerImpErrCallResponse, 1)

	call := &FileScannerImpErrCall{
		responseChan: responseChan,
	}

	callEvent := &FileScannerImpCall{
		err: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Next implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileScannerImpMock) Next() (filesystem.FileInfo, bool) {
	responseChan := make(chan FileScannerImpNextCallResponse, 1)

	call := &FileScannerImpNextCall{
		responseChan: responseChan,
	}

	callEvent := &FileScannerImpCall{
		next: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// FileScannerImpNextBuilder provides a fluent API for setting expectations on Next calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileScannerImpNextBuilder struct {
	imp     *FileScannerImp
	timeout _time.Duration
}

// InjectPanic waits for a Next call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileScannerImpNextBuilder) InjectPanic(msg any) *FileScannerImpNextCall {
	validator := func(callToCheck *FileScannerImpCall) bool {
		return callToCheck.Name() == "Next"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNext()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Next call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileScannerImpNextBuilder) InjectResults(r0 filesystem.FileInfo, r1 bool) *FileScannerImpNextCall {
	validator := func(callToCheck *FileScannerImpCall) bool {
		return callToCheck.Name() == "Next"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNext()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileScannerImpNextCall represents a captured call to the Next method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileScannerImpNextCall struct {
	responseChan chan FileScannerImpNextCallResponse
	done         bool
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileScannerImpNextCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileScannerImpNextCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileScannerImpNextCall) InjectResults(r0 filesystem.FileInfo, r1 bool) {
	c.done = true
	resp := FileScannerImpNextCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileScannerImpNextCallResponse holds the response configuration for the Next method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileScannerImpNextCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    filesystem.FileInfo
	Result1    bool
	PanicValue any
}

// FileScannerImpTimed provides timeout-configured expectation methods.
// Access via FileScannerImp.Within(duration) to set a timeout for expectations.
type FileScannerImpTimed struct {
	ExpectCallIs *FileScannerImpExpectCallIs
}

// unexported variables.
var (
	// Compile-time verification that FileScannerImpMock implements filesystem.FileScanner.
	_ filesystem.FileScanner = (*FileScannerImpMock)(nil)
)
