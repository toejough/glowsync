// Code generated by impgen. DO NOT EDIT.

package filesystem_test

import (
	"os"
	"path/filepath"
	"reflect"
	"testing"
	"time"

	"github.com/joe/copy-files/pkg/filesystem"
	"github.com/toejough/imptest/imptest"
)

// Type alias for File to make generated code work
type File = filesystem.File

// FileSystemImp is the test controller for mocking the interface.
// Create with NewFileSystemImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewFileSystemImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type FileSystemImp struct {
	*imptest.Controller[*FileSystemImpCall]
	Mock         *FileSystemImpMock
	ExpectCallIs *FileSystemImpExpectCallIs
	currentCall  *FileSystemImpCall
}

// NewFileSystemImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewFileSystemImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewFileSystemImp(t *testing.T) *FileSystemImp {
	imp := &FileSystemImp{
		Controller: imptest.NewController[*FileSystemImpCall](t),
	}
	imp.Mock = &FileSystemImpMock{imp: imp}
	imp.ExpectCallIs = &FileSystemImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *FileSystemImp) GetCurrentCall() *FileSystemImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *FileSystemImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a FileSystemImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *FileSystemImp) Within(d time.Duration) *FileSystemImpTimed {
	return &FileSystemImpTimed{
		ExpectCallIs: &FileSystemImpExpectCallIs{imp: i, timeout: d},
	}
}

// FileSystemImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type FileSystemImpCall struct {
	Stat      *FileSystemImpStatCall
	ReadFile  *FileSystemImpReadFileCall
	WriteFile *FileSystemImpWriteFileCall
	Remove    *FileSystemImpRemoveCall
	RemoveAll *FileSystemImpRemoveAllCall
	Chtimes   *FileSystemImpChtimesCall
	MkdirAll  *FileSystemImpMkdirAllCall
	Open      *FileSystemImpOpenCall
	Create    *FileSystemImpCreateCall
	Walk      *FileSystemImpWalkCall
}

// AsChtimes returns the call cast to FileSystemImpChtimesCall for accessing call details.
// Returns nil if the call was not to Chtimes.
func (c *FileSystemImpCall) AsChtimes() *FileSystemImpChtimesCall {
	return c.Chtimes
}

// AsCreate returns the call cast to FileSystemImpCreateCall for accessing call details.
// Returns nil if the call was not to Create.
func (c *FileSystemImpCall) AsCreate() *FileSystemImpCreateCall {
	return c.Create
}

// AsMkdirAll returns the call cast to FileSystemImpMkdirAllCall for accessing call details.
// Returns nil if the call was not to MkdirAll.
func (c *FileSystemImpCall) AsMkdirAll() *FileSystemImpMkdirAllCall {
	return c.MkdirAll
}

// AsOpen returns the call cast to FileSystemImpOpenCall for accessing call details.
// Returns nil if the call was not to Open.
func (c *FileSystemImpCall) AsOpen() *FileSystemImpOpenCall {
	return c.Open
}

// AsReadFile returns the call cast to FileSystemImpReadFileCall for accessing call details.
// Returns nil if the call was not to ReadFile.
func (c *FileSystemImpCall) AsReadFile() *FileSystemImpReadFileCall {
	return c.ReadFile
}

// AsRemove returns the call cast to FileSystemImpRemoveCall for accessing call details.
// Returns nil if the call was not to Remove.
func (c *FileSystemImpCall) AsRemove() *FileSystemImpRemoveCall {
	return c.Remove
}

// AsRemoveAll returns the call cast to FileSystemImpRemoveAllCall for accessing call details.
// Returns nil if the call was not to RemoveAll.
func (c *FileSystemImpCall) AsRemoveAll() *FileSystemImpRemoveAllCall {
	return c.RemoveAll
}

// AsStat returns the call cast to FileSystemImpStatCall for accessing call details.
// Returns nil if the call was not to Stat.
func (c *FileSystemImpCall) AsStat() *FileSystemImpStatCall {
	return c.Stat
}

// AsWalk returns the call cast to FileSystemImpWalkCall for accessing call details.
// Returns nil if the call was not to Walk.
func (c *FileSystemImpCall) AsWalk() *FileSystemImpWalkCall {
	return c.Walk
}

// AsWriteFile returns the call cast to FileSystemImpWriteFileCall for accessing call details.
// Returns nil if the call was not to WriteFile.
func (c *FileSystemImpCall) AsWriteFile() *FileSystemImpWriteFileCall {
	return c.WriteFile
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *FileSystemImpCall) Done() bool {
	if c.Stat != nil {
		return c.Stat.done
	}
	if c.ReadFile != nil {
		return c.ReadFile.done
	}
	if c.WriteFile != nil {
		return c.WriteFile.done
	}
	if c.Remove != nil {
		return c.Remove.done
	}
	if c.RemoveAll != nil {
		return c.RemoveAll.done
	}
	if c.Chtimes != nil {
		return c.Chtimes.done
	}
	if c.MkdirAll != nil {
		return c.MkdirAll.done
	}
	if c.Open != nil {
		return c.Open.done
	}
	if c.Create != nil {
		return c.Create.done
	}
	if c.Walk != nil {
		return c.Walk.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *FileSystemImpCall) Name() string {
	if c.Stat != nil {
		return "Stat"
	}
	if c.ReadFile != nil {
		return "ReadFile"
	}
	if c.WriteFile != nil {
		return "WriteFile"
	}
	if c.Remove != nil {
		return "Remove"
	}
	if c.RemoveAll != nil {
		return "RemoveAll"
	}
	if c.Chtimes != nil {
		return "Chtimes"
	}
	if c.MkdirAll != nil {
		return "MkdirAll"
	}
	if c.Open != nil {
		return "Open"
	}
	if c.Create != nil {
		return "Create"
	}
	if c.Walk != nil {
		return "Walk"
	}
	return ""
}

// FileSystemImpChtimesBuilder provides a fluent API for setting expectations on Chtimes calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpChtimesBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Chtimes call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpChtimesBuilder) ExpectArgsAre(path string, atime time.Time, mtime time.Time) *FileSystemImpChtimesCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Chtimes" {
			return false
		}
		methodCall := callToCheck.AsChtimes()
		if methodCall.path != path {
			return false
		}
		if !reflect.DeepEqual(methodCall.atime, atime) {
			return false
		}
		if !reflect.DeepEqual(methodCall.mtime, mtime) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsChtimes()
}

// ExpectArgsShould waits for a Chtimes call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpChtimesBuilder) ExpectArgsShould(path any, atime any, mtime any) *FileSystemImpChtimesCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Chtimes" {
			return false
		}
		methodCall := callToCheck.AsChtimes()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.atime, atime)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.mtime, mtime)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsChtimes()
}

// InjectPanic waits for a Chtimes call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpChtimesBuilder) InjectPanic(msg any) *FileSystemImpChtimesCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Chtimes"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsChtimes()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Chtimes call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpChtimesBuilder) InjectResult(result error) *FileSystemImpChtimesCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Chtimes"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsChtimes()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpChtimesCall represents a captured call to the Chtimes method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpChtimesCall struct {
	responseChan chan FileSystemImpChtimesCallResponse
	done         bool
	path         string
	atime        time.Time
	mtime        time.Time
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpChtimesCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpChtimesCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpChtimesCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpChtimesCallResponse{Type: "return", Result0: result}
}

// FileSystemImpChtimesCallResponse holds the response configuration for the Chtimes method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpChtimesCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileSystemImpCreateBuilder provides a fluent API for setting expectations on Create calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpCreateBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Create call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpCreateBuilder) ExpectArgsAre(path string) *FileSystemImpCreateCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Create" {
			return false
		}
		methodCall := callToCheck.AsCreate()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsCreate()
}

// ExpectArgsShould waits for a Create call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpCreateBuilder) ExpectArgsShould(path any) *FileSystemImpCreateCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Create" {
			return false
		}
		methodCall := callToCheck.AsCreate()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsCreate()
}

// InjectPanic waits for a Create call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpCreateBuilder) InjectPanic(msg any) *FileSystemImpCreateCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Create"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsCreate()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Create call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpCreateBuilder) InjectResults(r0 File, r1 error) *FileSystemImpCreateCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Create"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsCreate()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileSystemImpCreateCall represents a captured call to the Create method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpCreateCall struct {
	responseChan chan FileSystemImpCreateCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpCreateCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpCreateCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileSystemImpCreateCall) InjectResults(r0 File, r1 error) {
	c.done = true
	resp := FileSystemImpCreateCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileSystemImpCreateCallResponse holds the response configuration for the Create method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpCreateCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    File
	Result1    error
	PanicValue any
}

// FileSystemImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent FileSystemImp to configure timeouts.
type FileSystemImpExpectCallIs struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// Chtimes returns a builder for setting expectations on Chtimes method calls.
func (e *FileSystemImpExpectCallIs) Chtimes() *FileSystemImpChtimesBuilder {
	return &FileSystemImpChtimesBuilder{imp: e.imp, timeout: e.timeout}
}

// Create returns a builder for setting expectations on Create method calls.
func (e *FileSystemImpExpectCallIs) Create() *FileSystemImpCreateBuilder {
	return &FileSystemImpCreateBuilder{imp: e.imp, timeout: e.timeout}
}

// MkdirAll returns a builder for setting expectations on MkdirAll method calls.
func (e *FileSystemImpExpectCallIs) MkdirAll() *FileSystemImpMkdirAllBuilder {
	return &FileSystemImpMkdirAllBuilder{imp: e.imp, timeout: e.timeout}
}

// Open returns a builder for setting expectations on Open method calls.
func (e *FileSystemImpExpectCallIs) Open() *FileSystemImpOpenBuilder {
	return &FileSystemImpOpenBuilder{imp: e.imp, timeout: e.timeout}
}

// ReadFile returns a builder for setting expectations on ReadFile method calls.
func (e *FileSystemImpExpectCallIs) ReadFile() *FileSystemImpReadFileBuilder {
	return &FileSystemImpReadFileBuilder{imp: e.imp, timeout: e.timeout}
}

// Remove returns a builder for setting expectations on Remove method calls.
func (e *FileSystemImpExpectCallIs) Remove() *FileSystemImpRemoveBuilder {
	return &FileSystemImpRemoveBuilder{imp: e.imp, timeout: e.timeout}
}

// RemoveAll returns a builder for setting expectations on RemoveAll method calls.
func (e *FileSystemImpExpectCallIs) RemoveAll() *FileSystemImpRemoveAllBuilder {
	return &FileSystemImpRemoveAllBuilder{imp: e.imp, timeout: e.timeout}
}

// Stat returns a builder for setting expectations on Stat method calls.
func (e *FileSystemImpExpectCallIs) Stat() *FileSystemImpStatBuilder {
	return &FileSystemImpStatBuilder{imp: e.imp, timeout: e.timeout}
}

// Walk returns a builder for setting expectations on Walk method calls.
func (e *FileSystemImpExpectCallIs) Walk() *FileSystemImpWalkBuilder {
	return &FileSystemImpWalkBuilder{imp: e.imp, timeout: e.timeout}
}

// WriteFile returns a builder for setting expectations on WriteFile method calls.
func (e *FileSystemImpExpectCallIs) WriteFile() *FileSystemImpWriteFileBuilder {
	return &FileSystemImpWriteFileBuilder{imp: e.imp, timeout: e.timeout}
}

// FileSystemImpMkdirAllBuilder provides a fluent API for setting expectations on MkdirAll calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpMkdirAllBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a MkdirAll call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpMkdirAllBuilder) ExpectArgsAre(path string, perm os.FileMode) *FileSystemImpMkdirAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "MkdirAll" {
			return false
		}
		methodCall := callToCheck.AsMkdirAll()
		if methodCall.path != path {
			return false
		}
		if !reflect.DeepEqual(methodCall.perm, perm) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsMkdirAll()
}

// ExpectArgsShould waits for a MkdirAll call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpMkdirAllBuilder) ExpectArgsShould(path any, perm any) *FileSystemImpMkdirAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "MkdirAll" {
			return false
		}
		methodCall := callToCheck.AsMkdirAll()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.perm, perm)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsMkdirAll()
}

// InjectPanic waits for a MkdirAll call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpMkdirAllBuilder) InjectPanic(msg any) *FileSystemImpMkdirAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "MkdirAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsMkdirAll()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a MkdirAll call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpMkdirAllBuilder) InjectResult(result error) *FileSystemImpMkdirAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "MkdirAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsMkdirAll()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpMkdirAllCall represents a captured call to the MkdirAll method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpMkdirAllCall struct {
	responseChan chan FileSystemImpMkdirAllCallResponse
	done         bool
	path         string
	perm         os.FileMode
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpMkdirAllCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpMkdirAllCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpMkdirAllCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpMkdirAllCallResponse{Type: "return", Result0: result}
}

// FileSystemImpMkdirAllCallResponse holds the response configuration for the MkdirAll method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpMkdirAllCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileSystemImpMock provides the mock implementation of the interface.
// Pass FileSystemImpMock to code under test that expects the interface implementation.
// Use the parent FileSystemImp controller to set expectations and inject responses.
type FileSystemImpMock struct {
	imp *FileSystemImp
}

// Chtimes implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Chtimes(path string, atime time.Time, mtime time.Time) error {
	responseChan := make(chan FileSystemImpChtimesCallResponse, 1)

	call := &FileSystemImpChtimesCall{
		responseChan: responseChan,
		path:         path,
		atime:        atime,
		mtime:        mtime,
	}

	callEvent := &FileSystemImpCall{
		Chtimes: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Create implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Create(path string) (filesystem.File, error) {
	responseChan := make(chan FileSystemImpCreateCallResponse, 1)

	call := &FileSystemImpCreateCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		Create: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// MkdirAll implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) MkdirAll(path string, perm os.FileMode) error {
	responseChan := make(chan FileSystemImpMkdirAllCallResponse, 1)

	call := &FileSystemImpMkdirAllCall{
		responseChan: responseChan,
		path:         path,
		perm:         perm,
	}

	callEvent := &FileSystemImpCall{
		MkdirAll: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Open implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Open(path string) (filesystem.File, error) {
	responseChan := make(chan FileSystemImpOpenCallResponse, 1)

	call := &FileSystemImpOpenCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		Open: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// ReadFile implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) ReadFile(path string) ([]byte, error) {
	responseChan := make(chan FileSystemImpReadFileCallResponse, 1)

	call := &FileSystemImpReadFileCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		ReadFile: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// Remove implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Remove(path string) error {
	responseChan := make(chan FileSystemImpRemoveCallResponse, 1)

	call := &FileSystemImpRemoveCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		Remove: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// RemoveAll implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) RemoveAll(path string) error {
	responseChan := make(chan FileSystemImpRemoveAllCallResponse, 1)

	call := &FileSystemImpRemoveAllCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		RemoveAll: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Stat implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Stat(path string) (os.FileInfo, error) {
	responseChan := make(chan FileSystemImpStatCallResponse, 1)

	call := &FileSystemImpStatCall{
		responseChan: responseChan,
		path:         path,
	}

	callEvent := &FileSystemImpCall{
		Stat: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// Walk implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) Walk(root string, fn filepath.WalkFunc) error {
	responseChan := make(chan FileSystemImpWalkCallResponse, 1)

	call := &FileSystemImpWalkCall{
		responseChan: responseChan,
		root:         root,
		fn:           fn,
	}

	callEvent := &FileSystemImpCall{
		Walk: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// WriteFile implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileSystemImpMock) WriteFile(path string, data []byte, perm os.FileMode) error {
	responseChan := make(chan FileSystemImpWriteFileCallResponse, 1)

	call := &FileSystemImpWriteFileCall{
		responseChan: responseChan,
		path:         path,
		data:         data,
		perm:         perm,
	}

	callEvent := &FileSystemImpCall{
		WriteFile: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// FileSystemImpOpenBuilder provides a fluent API for setting expectations on Open calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpOpenBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Open call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpOpenBuilder) ExpectArgsAre(path string) *FileSystemImpOpenCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Open" {
			return false
		}
		methodCall := callToCheck.AsOpen()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsOpen()
}

// ExpectArgsShould waits for a Open call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpOpenBuilder) ExpectArgsShould(path any) *FileSystemImpOpenCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Open" {
			return false
		}
		methodCall := callToCheck.AsOpen()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsOpen()
}

// InjectPanic waits for a Open call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpOpenBuilder) InjectPanic(msg any) *FileSystemImpOpenCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Open"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsOpen()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Open call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpOpenBuilder) InjectResults(r0 File, r1 error) *FileSystemImpOpenCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Open"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsOpen()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileSystemImpOpenCall represents a captured call to the Open method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpOpenCall struct {
	responseChan chan FileSystemImpOpenCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpOpenCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpOpenCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileSystemImpOpenCall) InjectResults(r0 File, r1 error) {
	c.done = true
	resp := FileSystemImpOpenCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileSystemImpOpenCallResponse holds the response configuration for the Open method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpOpenCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    File
	Result1    error
	PanicValue any
}

// FileSystemImpReadFileBuilder provides a fluent API for setting expectations on ReadFile calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpReadFileBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a ReadFile call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpReadFileBuilder) ExpectArgsAre(path string) *FileSystemImpReadFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "ReadFile" {
			return false
		}
		methodCall := callToCheck.AsReadFile()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReadFile()
}

// ExpectArgsShould waits for a ReadFile call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpReadFileBuilder) ExpectArgsShould(path any) *FileSystemImpReadFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "ReadFile" {
			return false
		}
		methodCall := callToCheck.AsReadFile()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReadFile()
}

// InjectPanic waits for a ReadFile call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpReadFileBuilder) InjectPanic(msg any) *FileSystemImpReadFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "ReadFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReadFile()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a ReadFile call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpReadFileBuilder) InjectResults(r0 []byte, r1 error) *FileSystemImpReadFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "ReadFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReadFile()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileSystemImpReadFileCall represents a captured call to the ReadFile method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpReadFileCall struct {
	responseChan chan FileSystemImpReadFileCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpReadFileCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpReadFileCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileSystemImpReadFileCall) InjectResults(r0 []byte, r1 error) {
	c.done = true
	resp := FileSystemImpReadFileCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileSystemImpReadFileCallResponse holds the response configuration for the ReadFile method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpReadFileCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    []byte
	Result1    error
	PanicValue any
}

// FileSystemImpRemoveAllBuilder provides a fluent API for setting expectations on RemoveAll calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpRemoveAllBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a RemoveAll call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpRemoveAllBuilder) ExpectArgsAre(path string) *FileSystemImpRemoveAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "RemoveAll" {
			return false
		}
		methodCall := callToCheck.AsRemoveAll()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRemoveAll()
}

// ExpectArgsShould waits for a RemoveAll call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpRemoveAllBuilder) ExpectArgsShould(path any) *FileSystemImpRemoveAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "RemoveAll" {
			return false
		}
		methodCall := callToCheck.AsRemoveAll()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRemoveAll()
}

// InjectPanic waits for a RemoveAll call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpRemoveAllBuilder) InjectPanic(msg any) *FileSystemImpRemoveAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "RemoveAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRemoveAll()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a RemoveAll call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpRemoveAllBuilder) InjectResult(result error) *FileSystemImpRemoveAllCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "RemoveAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRemoveAll()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpRemoveAllCall represents a captured call to the RemoveAll method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpRemoveAllCall struct {
	responseChan chan FileSystemImpRemoveAllCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpRemoveAllCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpRemoveAllCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpRemoveAllCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpRemoveAllCallResponse{Type: "return", Result0: result}
}

// FileSystemImpRemoveAllCallResponse holds the response configuration for the RemoveAll method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpRemoveAllCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileSystemImpRemoveBuilder provides a fluent API for setting expectations on Remove calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpRemoveBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Remove call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpRemoveBuilder) ExpectArgsAre(path string) *FileSystemImpRemoveCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Remove" {
			return false
		}
		methodCall := callToCheck.AsRemove()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRemove()
}

// ExpectArgsShould waits for a Remove call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpRemoveBuilder) ExpectArgsShould(path any) *FileSystemImpRemoveCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Remove" {
			return false
		}
		methodCall := callToCheck.AsRemove()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRemove()
}

// InjectPanic waits for a Remove call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpRemoveBuilder) InjectPanic(msg any) *FileSystemImpRemoveCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Remove"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRemove()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Remove call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpRemoveBuilder) InjectResult(result error) *FileSystemImpRemoveCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Remove"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRemove()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpRemoveCall represents a captured call to the Remove method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpRemoveCall struct {
	responseChan chan FileSystemImpRemoveCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpRemoveCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpRemoveCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpRemoveCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpRemoveCallResponse{Type: "return", Result0: result}
}

// FileSystemImpRemoveCallResponse holds the response configuration for the Remove method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpRemoveCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileSystemImpStatBuilder provides a fluent API for setting expectations on Stat calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpStatBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Stat call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpStatBuilder) ExpectArgsAre(path string) *FileSystemImpStatCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Stat" {
			return false
		}
		methodCall := callToCheck.AsStat()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStat()
}

// ExpectArgsShould waits for a Stat call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpStatBuilder) ExpectArgsShould(path any) *FileSystemImpStatCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Stat" {
			return false
		}
		methodCall := callToCheck.AsStat()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStat()
}

// InjectPanic waits for a Stat call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpStatBuilder) InjectPanic(msg any) *FileSystemImpStatCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Stat"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStat()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Stat call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpStatBuilder) InjectResults(r0 os.FileInfo, r1 error) *FileSystemImpStatCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Stat"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStat()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileSystemImpStatCall represents a captured call to the Stat method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpStatCall struct {
	responseChan chan FileSystemImpStatCallResponse
	done         bool
	path         string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpStatCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpStatCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileSystemImpStatCall) InjectResults(r0 os.FileInfo, r1 error) {
	c.done = true
	resp := FileSystemImpStatCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileSystemImpStatCallResponse holds the response configuration for the Stat method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpStatCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    os.FileInfo
	Result1    error
	PanicValue any
}

// FileSystemImpTimed provides timeout-configured expectation methods.
// Access via FileSystemImp.Within(duration) to set a timeout for expectations.
type FileSystemImpTimed struct {
	ExpectCallIs *FileSystemImpExpectCallIs
}

// FileSystemImpWalkBuilder provides a fluent API for setting expectations on Walk calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpWalkBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a Walk call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpWalkBuilder) ExpectArgsAre(root string, fn filepath.WalkFunc) *FileSystemImpWalkCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Walk" {
			return false
		}
		methodCall := callToCheck.AsWalk()
		if methodCall.root != root {
			return false
		}
		if !reflect.DeepEqual(methodCall.fn, fn) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalk()
}

// ExpectArgsShould waits for a Walk call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpWalkBuilder) ExpectArgsShould(root any, fn any) *FileSystemImpWalkCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "Walk" {
			return false
		}
		methodCall := callToCheck.AsWalk()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.root, root)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.fn, fn)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalk()
}

// InjectPanic waits for a Walk call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpWalkBuilder) InjectPanic(msg any) *FileSystemImpWalkCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Walk"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalk()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Walk call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpWalkBuilder) InjectResult(result error) *FileSystemImpWalkCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "Walk"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalk()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpWalkCall represents a captured call to the Walk method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpWalkCall struct {
	responseChan chan FileSystemImpWalkCallResponse
	done         bool
	root         string
	fn           filepath.WalkFunc
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpWalkCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpWalkCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpWalkCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpWalkCallResponse{Type: "return", Result0: result}
}

// FileSystemImpWalkCallResponse holds the response configuration for the Walk method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpWalkCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// FileSystemImpWriteFileBuilder provides a fluent API for setting expectations on WriteFile calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileSystemImpWriteFileBuilder struct {
	imp     *FileSystemImp
	timeout time.Duration
}

// ExpectArgsAre waits for a WriteFile call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileSystemImpWriteFileBuilder) ExpectArgsAre(path string, data []byte, perm os.FileMode) *FileSystemImpWriteFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "WriteFile" {
			return false
		}
		methodCall := callToCheck.AsWriteFile()
		if methodCall.path != path {
			return false
		}
		if !reflect.DeepEqual(methodCall.data, data) {
			return false
		}
		if !reflect.DeepEqual(methodCall.perm, perm) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWriteFile()
}

// ExpectArgsShould waits for a WriteFile call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileSystemImpWriteFileBuilder) ExpectArgsShould(path any, data any, perm any) *FileSystemImpWriteFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		if callToCheck.Name() != "WriteFile" {
			return false
		}
		methodCall := callToCheck.AsWriteFile()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.data, data)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.perm, perm)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWriteFile()
}

// InjectPanic waits for a WriteFile call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileSystemImpWriteFileBuilder) InjectPanic(msg any) *FileSystemImpWriteFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "WriteFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWriteFile()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a WriteFile call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileSystemImpWriteFileBuilder) InjectResult(result error) *FileSystemImpWriteFileCall {
	validator := func(callToCheck *FileSystemImpCall) bool {
		return callToCheck.Name() == "WriteFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWriteFile()
	methodCall.InjectResult(result)
	return methodCall
}

// FileSystemImpWriteFileCall represents a captured call to the WriteFile method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileSystemImpWriteFileCall struct {
	responseChan chan FileSystemImpWriteFileCallResponse
	done         bool
	path         string
	data         []byte
	perm         os.FileMode
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileSystemImpWriteFileCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileSystemImpWriteFileCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *FileSystemImpWriteFileCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- FileSystemImpWriteFileCallResponse{Type: "return", Result0: result}
}

// FileSystemImpWriteFileCallResponse holds the response configuration for the WriteFile method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileSystemImpWriteFileCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// unexported variables.
var (
	// Compile-time verification that FileSystemImpMock implements filesystem.FileSystem.
	_ filesystem.FileSystem = (*FileSystemImpMock)(nil)
)
