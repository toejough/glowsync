// Code generated by impgen. DO NOT EDIT.

package fileops_test

import (
	filesystem "github.com/joe/copy-files/pkg/filesystem"
	_imptest "github.com/toejough/imptest/imptest"
	os "os"
	time "time"
)

// FileSystemMock is the mock for FileSystem.
type FileSystemMock struct {
	imp      *_imptest.Imp
	Scan     *FileSystemMockScanMethod
	Open     *FileSystemMockOpenMethod
	Create   *FileSystemMockCreateMethod
	MkdirAll *FileSystemMockMkdirAllMethod
	Chtimes  *FileSystemMockChtimesMethod
	Remove   *FileSystemMockRemoveMethod
	Stat     *FileSystemMockStatMethod
}

// Interface returns the FileSystem implementation that can be passed to code under test.
func (m *FileSystemMock) Interface() filesystem.FileSystem {
	return &mockFileSystemImpl{mock: m}
}

// FileSystemMockChtimesArgs holds typed arguments for Chtimes.
type FileSystemMockChtimesArgs struct {
	Path  string
	Atime time.Time
	Mtime time.Time
}

// FileSystemMockChtimesCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockChtimesCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockChtimesCall) GetArgs() FileSystemMockChtimesArgs {
	raw := c.RawArgs()
	return FileSystemMockChtimesArgs{
		Path:  raw[0].(string),
		Atime: raw[1].(time.Time),
		Mtime: raw[2].(time.Time),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockChtimesCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// FileSystemMockChtimesMethod wraps DependencyMethod with typed returns.
type FileSystemMockChtimesMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockChtimesMethod) Eventually() *FileSystemMockChtimesMethod {
	return &FileSystemMockChtimesMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockChtimesMethod) ExpectCalledWithExactly(path string, atime time.Time, mtime time.Time) *FileSystemMockChtimesCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path, atime, mtime)
	return &FileSystemMockChtimesCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockChtimesMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockChtimesCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockChtimesCall{DependencyCall: call}
}

// FileSystemMockCreateArgs holds typed arguments for Create.
type FileSystemMockCreateArgs struct {
	Path string
}

// FileSystemMockCreateCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockCreateCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockCreateCall) GetArgs() FileSystemMockCreateArgs {
	raw := c.RawArgs()
	return FileSystemMockCreateArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockCreateCall) InjectReturnValues(result0 filesystem.File, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileSystemMockCreateMethod wraps DependencyMethod with typed returns.
type FileSystemMockCreateMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockCreateMethod) Eventually() *FileSystemMockCreateMethod {
	return &FileSystemMockCreateMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockCreateMethod) ExpectCalledWithExactly(path string) *FileSystemMockCreateCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileSystemMockCreateCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockCreateMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockCreateCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockCreateCall{DependencyCall: call}
}

// FileSystemMockMkdirAllArgs holds typed arguments for MkdirAll.
type FileSystemMockMkdirAllArgs struct {
	Path string
	Perm os.FileMode
}

// FileSystemMockMkdirAllCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockMkdirAllCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockMkdirAllCall) GetArgs() FileSystemMockMkdirAllArgs {
	raw := c.RawArgs()
	return FileSystemMockMkdirAllArgs{
		Path: raw[0].(string),
		Perm: raw[1].(os.FileMode),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockMkdirAllCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// FileSystemMockMkdirAllMethod wraps DependencyMethod with typed returns.
type FileSystemMockMkdirAllMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockMkdirAllMethod) Eventually() *FileSystemMockMkdirAllMethod {
	return &FileSystemMockMkdirAllMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockMkdirAllMethod) ExpectCalledWithExactly(path string, perm os.FileMode) *FileSystemMockMkdirAllCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path, perm)
	return &FileSystemMockMkdirAllCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockMkdirAllMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockMkdirAllCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockMkdirAllCall{DependencyCall: call}
}

// FileSystemMockOpenArgs holds typed arguments for Open.
type FileSystemMockOpenArgs struct {
	Path string
}

// FileSystemMockOpenCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockOpenCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockOpenCall) GetArgs() FileSystemMockOpenArgs {
	raw := c.RawArgs()
	return FileSystemMockOpenArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockOpenCall) InjectReturnValues(result0 filesystem.File, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileSystemMockOpenMethod wraps DependencyMethod with typed returns.
type FileSystemMockOpenMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockOpenMethod) Eventually() *FileSystemMockOpenMethod {
	return &FileSystemMockOpenMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockOpenMethod) ExpectCalledWithExactly(path string) *FileSystemMockOpenCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileSystemMockOpenCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockOpenMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockOpenCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockOpenCall{DependencyCall: call}
}

// FileSystemMockRemoveArgs holds typed arguments for Remove.
type FileSystemMockRemoveArgs struct {
	Path string
}

// FileSystemMockRemoveCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockRemoveCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockRemoveCall) GetArgs() FileSystemMockRemoveArgs {
	raw := c.RawArgs()
	return FileSystemMockRemoveArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockRemoveCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// FileSystemMockRemoveMethod wraps DependencyMethod with typed returns.
type FileSystemMockRemoveMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockRemoveMethod) Eventually() *FileSystemMockRemoveMethod {
	return &FileSystemMockRemoveMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockRemoveMethod) ExpectCalledWithExactly(path string) *FileSystemMockRemoveCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileSystemMockRemoveCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockRemoveMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockRemoveCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockRemoveCall{DependencyCall: call}
}

// FileSystemMockScanArgs holds typed arguments for Scan.
type FileSystemMockScanArgs struct {
	Path string
}

// FileSystemMockScanCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockScanCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockScanCall) GetArgs() FileSystemMockScanArgs {
	raw := c.RawArgs()
	return FileSystemMockScanArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockScanCall) InjectReturnValues(result0 filesystem.FileScanner) {
	c.DependencyCall.InjectReturnValues(result0)
}

// FileSystemMockScanMethod wraps DependencyMethod with typed returns.
type FileSystemMockScanMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockScanMethod) Eventually() *FileSystemMockScanMethod {
	return &FileSystemMockScanMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockScanMethod) ExpectCalledWithExactly(path string) *FileSystemMockScanCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileSystemMockScanCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockScanMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockScanCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockScanCall{DependencyCall: call}
}

// FileSystemMockStatArgs holds typed arguments for Stat.
type FileSystemMockStatArgs struct {
	Path string
}

// FileSystemMockStatCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileSystemMockStatCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileSystemMockStatCall) GetArgs() FileSystemMockStatArgs {
	raw := c.RawArgs()
	return FileSystemMockStatArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileSystemMockStatCall) InjectReturnValues(result0 os.FileInfo, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileSystemMockStatMethod wraps DependencyMethod with typed returns.
type FileSystemMockStatMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *FileSystemMockStatMethod) Eventually() *FileSystemMockStatMethod {
	return &FileSystemMockStatMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileSystemMockStatMethod) ExpectCalledWithExactly(path string) *FileSystemMockStatCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileSystemMockStatCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileSystemMockStatMethod) ExpectCalledWithMatches(matchers ...any) *FileSystemMockStatCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileSystemMockStatCall{DependencyCall: call}
}

// MockFileSystem creates a new FileSystemMock for testing.
func MockFileSystem(t _imptest.TestReporter) *FileSystemMock {
	imp := _imptest.NewImp(t)
	return &FileSystemMock{
		imp:      imp,
		Scan:     &FileSystemMockScanMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Scan")},
		Open:     &FileSystemMockOpenMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Open")},
		Create:   &FileSystemMockCreateMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Create")},
		MkdirAll: &FileSystemMockMkdirAllMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "MkdirAll")},
		Chtimes:  &FileSystemMockChtimesMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Chtimes")},
		Remove:   &FileSystemMockRemoveMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Remove")},
		Stat:     &FileSystemMockStatMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "Stat")},
	}
}

// mockFileSystemImpl implements filesystem.FileSystem.
type mockFileSystemImpl struct {
	mock *FileSystemMock
}

// Chtimes implements filesystem.FileSystem.Chtimes.
func (impl *mockFileSystemImpl) Chtimes(path string, atime time.Time, mtime time.Time) error {
	call := &_imptest.GenericCall{
		MethodName:   "Chtimes",
		Args:         []any{path, atime, mtime},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// Create implements filesystem.FileSystem.Create.
func (impl *mockFileSystemImpl) Create(path string) (filesystem.File, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Create",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 filesystem.File
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(filesystem.File); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// MkdirAll implements filesystem.FileSystem.MkdirAll.
func (impl *mockFileSystemImpl) MkdirAll(path string, perm os.FileMode) error {
	call := &_imptest.GenericCall{
		MethodName:   "MkdirAll",
		Args:         []any{path, perm},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// Open implements filesystem.FileSystem.Open.
func (impl *mockFileSystemImpl) Open(path string) (filesystem.File, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Open",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 filesystem.File
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(filesystem.File); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Remove implements filesystem.FileSystem.Remove.
func (impl *mockFileSystemImpl) Remove(path string) error {
	call := &_imptest.GenericCall{
		MethodName:   "Remove",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// Scan implements filesystem.FileSystem.Scan.
func (impl *mockFileSystemImpl) Scan(path string) filesystem.FileScanner {
	call := &_imptest.GenericCall{
		MethodName:   "Scan",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 filesystem.FileScanner
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(filesystem.FileScanner); ok {
			result1 = value
		}
	}

	return result1
}

// Stat implements filesystem.FileSystem.Stat.
func (impl *mockFileSystemImpl) Stat(path string) (os.FileInfo, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Stat",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 os.FileInfo
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(os.FileInfo); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}
