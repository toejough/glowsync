{
  "entries": {
    "fileops.ComputeFileHash": {
      "signature": "580200ebfda3e95eabfdfda9b938802e31bb8d9893ff28af7cab5b4614c9683d",
      "content": "// Code generated by impgen. DO NOT EDIT.\n\npackage fileops_test\n\nimport (\n\t\"github.com/toejough/imptest/imptest\"\n\t\"testing\"\n)\n\n// ComputeFileHashImp wraps a callable function for testing.\n// Create with NewComputeFileHashImp(t, yourFunction), call Start() to execute,\n// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.\ntype ComputeFileHashImp struct {\n\t*imptest.CallableController[ComputeFileHashImpReturn]\n\tcallable func(filePath string) (string, error)\n}\n\n// NewComputeFileHashImp creates a new wrapper for testing the callable function.\n// Pass the function to test and a testing.TB to enable assertion failures.\n//\n// Example:\n//\n//\twrapper := NewComputeFileHashImp(t, myFunction)\n//\twrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)\nfunc NewComputeFileHashImp(t testing.TB, callable func(filePath string) (string, error)) *ComputeFileHashImp {\n\treturn \u0026ComputeFileHashImp{\n\t\tCallableController: imptest.NewCallableController[ComputeFileHashImpReturn](t),\n\t\tcallable:           callable,\n\t}\n}\n\n// ExpectPanicWith asserts the callable panicked with a value matching the expectation.\n// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if the callable returned normally or panicked with a different value.\nfunc (s *ComputeFileHashImp) ExpectPanicWith(expected any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Panicked != nil {\n\t\tok, msg := imptest.MatchValue(s.Panicked, expected)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"panic value: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to panic, but it returned\")\n}\n\n// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.\n// Fails the test if the values don't match exactly or if the callable panicked.\n// Uses == for comparison, so reference types must be the same instance.\nfunc (s *ComputeFileHashImp) ExpectReturnedValuesAre(v1 string, v2 error) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tif s.Returned.Result0 != v1 {\n\t\t\ts.T.Fatalf(\"expected return value 0 to be %v, got %v\", v1, s.Returned.Result0)\n\t\t}\n\t\tif s.Returned.Result1 != v2 {\n\t\t\ts.T.Fatalf(\"expected return value 1 to be %v, got %v\", v2, s.Returned.Result1)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// ExpectReturnedValuesShould asserts return values match the given matchers.\n// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if any matcher fails or if the callable panicked.\nfunc (s *ComputeFileHashImp) ExpectReturnedValuesShould(v1 any, v2 any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tvar ok bool\n\t\tvar msg string\n\t\tok, msg = imptest.MatchValue(s.Returned.Result0, v1)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 0: %s\", msg)\n\t\t}\n\t\tok, msg = imptest.MatchValue(s.Returned.Result1, v2)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 1: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// GetResponse waits for and returns the callable's response.\n// Use this when you need to inspect the response without asserting specific values.\n// The response indicates whether the callable returned or panicked.\nfunc (s *ComputeFileHashImp) GetResponse() *ComputeFileHashImpResponse {\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\treturn \u0026ComputeFileHashImpResponse{\n\t\t\tEventType: \"ReturnEvent\",\n\t\t\tReturnVal: s.Returned,\n\t\t}\n\t}\n\n\treturn \u0026ComputeFileHashImpResponse{\n\t\tEventType: \"PanicEvent\",\n\t\tPanicVal:  s.Panicked,\n\t}\n}\n\n// Start begins execution of the callable in a goroutine with the provided arguments.\n// Returns the wrapper for method chaining with expectation methods.\n// Captures both normal returns and panics for verification.\n//\n// Example:\n//\n//\twrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)\nfunc (s *ComputeFileHashImp) Start(filePath string) *ComputeFileHashImp {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\ts.PanicChan \u003c- r\n\t\t\t}\n\t\t}()\n\n\t\tret0, ret1 := s.callable(filePath)\n\t\ts.ReturnChan \u003c- ComputeFileHashImpReturn{\n\t\t\tResult0: ret0,\n\t\t\tResult1: ret1,\n\t\t}\n\t}()\n\treturn s\n}\n\n// ComputeFileHashImpResponse represents the response from the callable (either return or panic).\n// Check EventType to determine if the callable returned normally or panicked.\n// Use AsReturn() to get return values as a slice, or access PanicVal directly.\ntype ComputeFileHashImpResponse struct {\n\tEventType string // \"return\" or \"panic\"\n\tReturnVal *ComputeFileHashImpReturn\n\tPanicVal  any\n}\n\n// AsReturn converts the return values to a slice of any for generic processing.\n// Returns nil if the response was a panic or if there are no return values.\nfunc (r *ComputeFileHashImpResponse) AsReturn() []any {\n\tif r.ReturnVal == nil {\n\t\treturn nil\n\t}\n\treturn []any{r.ReturnVal.Result0, r.ReturnVal.Result1}\n}\n\n// Type returns the event type: \"return\" for normal returns, \"panic\" for panics.\nfunc (r *ComputeFileHashImpResponse) Type() string {\n\treturn r.EventType\n}\n\n// ComputeFileHashImpReturn holds the return values from the callable function.\n// Access individual return values via Result0, Result1, etc. fields.\ntype ComputeFileHashImpReturn struct {\n\tResult0 string\n\tResult1 error\n}\n",
      "filename": "generated_ComputeFileHashImp_test.go"
    },
    "fileops.CopyFile": {
      "signature": "34fb8a815a8298f8d068615100d989e87ed1a194751c8c3eb9dadea84d749ed2",
      "content": "// Code generated by impgen. DO NOT EDIT.\n\npackage fileops_test\n\nimport (\n\tfileops \"github.com/joe/copy-files/pkg/fileops\"\n\t\"github.com/toejough/imptest/imptest\"\n\t\"testing\"\n)\n\n// CopyFileImp wraps a callable function for testing.\n// Create with NewCopyFileImp(t, yourFunction), call Start() to execute,\n// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.\ntype CopyFileImp struct {\n\t*imptest.CallableController[CopyFileImpReturn]\n\tcallable func(src, dst string, progress fileops.ProgressCallback) (int64, error)\n}\n\n// NewCopyFileImp creates a new wrapper for testing the callable function.\n// Pass the function to test and a testing.TB to enable assertion failures.\n//\n// Example:\n//\n//\twrapper := NewCopyFileImp(t, myFunction)\n//\twrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)\nfunc NewCopyFileImp(t testing.TB, callable func(src, dst string, progress fileops.ProgressCallback) (int64, error)) *CopyFileImp {\n\treturn \u0026CopyFileImp{\n\t\tCallableController: imptest.NewCallableController[CopyFileImpReturn](t),\n\t\tcallable:           callable,\n\t}\n}\n\n// ExpectPanicWith asserts the callable panicked with a value matching the expectation.\n// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if the callable returned normally or panicked with a different value.\nfunc (s *CopyFileImp) ExpectPanicWith(expected any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Panicked != nil {\n\t\tok, msg := imptest.MatchValue(s.Panicked, expected)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"panic value: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to panic, but it returned\")\n}\n\n// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.\n// Fails the test if the values don't match exactly or if the callable panicked.\n// Uses == for comparison, so reference types must be the same instance.\nfunc (s *CopyFileImp) ExpectReturnedValuesAre(v1 int64, v2 error) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tif s.Returned.Result0 != v1 {\n\t\t\ts.T.Fatalf(\"expected return value 0 to be %v, got %v\", v1, s.Returned.Result0)\n\t\t}\n\t\tif s.Returned.Result1 != v2 {\n\t\t\ts.T.Fatalf(\"expected return value 1 to be %v, got %v\", v2, s.Returned.Result1)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// ExpectReturnedValuesShould asserts return values match the given matchers.\n// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if any matcher fails or if the callable panicked.\nfunc (s *CopyFileImp) ExpectReturnedValuesShould(v1 any, v2 any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tvar ok bool\n\t\tvar msg string\n\t\tok, msg = imptest.MatchValue(s.Returned.Result0, v1)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 0: %s\", msg)\n\t\t}\n\t\tok, msg = imptest.MatchValue(s.Returned.Result1, v2)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 1: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// GetResponse waits for and returns the callable's response.\n// Use this when you need to inspect the response without asserting specific values.\n// The response indicates whether the callable returned or panicked.\nfunc (s *CopyFileImp) GetResponse() *CopyFileImpResponse {\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\treturn \u0026CopyFileImpResponse{\n\t\t\tEventType: \"ReturnEvent\",\n\t\t\tReturnVal: s.Returned,\n\t\t}\n\t}\n\n\treturn \u0026CopyFileImpResponse{\n\t\tEventType: \"PanicEvent\",\n\t\tPanicVal:  s.Panicked,\n\t}\n}\n\n// Start begins execution of the callable in a goroutine with the provided arguments.\n// Returns the wrapper for method chaining with expectation methods.\n// Captures both normal returns and panics for verification.\n//\n// Example:\n//\n//\twrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)\nfunc (s *CopyFileImp) Start(src, dst string, progress fileops.ProgressCallback) *CopyFileImp {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\ts.PanicChan \u003c- r\n\t\t\t}\n\t\t}()\n\n\t\tret0, ret1 := s.callable(src, dst, progress)\n\t\ts.ReturnChan \u003c- CopyFileImpReturn{\n\t\t\tResult0: ret0,\n\t\t\tResult1: ret1,\n\t\t}\n\t}()\n\treturn s\n}\n\n// CopyFileImpResponse represents the response from the callable (either return or panic).\n// Check EventType to determine if the callable returned normally or panicked.\n// Use AsReturn() to get return values as a slice, or access PanicVal directly.\ntype CopyFileImpResponse struct {\n\tEventType string // \"return\" or \"panic\"\n\tReturnVal *CopyFileImpReturn\n\tPanicVal  any\n}\n\n// AsReturn converts the return values to a slice of any for generic processing.\n// Returns nil if the response was a panic or if there are no return values.\nfunc (r *CopyFileImpResponse) AsReturn() []any {\n\tif r.ReturnVal == nil {\n\t\treturn nil\n\t}\n\treturn []any{r.ReturnVal.Result0, r.ReturnVal.Result1}\n}\n\n// Type returns the event type: \"return\" for normal returns, \"panic\" for panics.\nfunc (r *CopyFileImpResponse) Type() string {\n\treturn r.EventType\n}\n\n// CopyFileImpReturn holds the return values from the callable function.\n// Access individual return values via Result0, Result1, etc. fields.\ntype CopyFileImpReturn struct {\n\tResult0 int64\n\tResult1 error\n}\n",
      "filename": "generated_CopyFileImp_test.go"
    },
    "fileops.FilesNeedSync": {
      "signature": "c6bf6b17fafbb80f9f80b51a8f185dbba262664f5468ed29e75b8e7f220fa1b6",
      "content": "// Code generated by impgen. DO NOT EDIT.\n\npackage fileops_test\n\nimport (\n\tfileops \"github.com/joe/copy-files/pkg/fileops\"\n\t\"github.com/toejough/imptest/imptest\"\n\t\"testing\"\n)\n\n// FilesNeedSyncImp wraps a callable function for testing.\n// Create with NewFilesNeedSyncImp(t, yourFunction), call Start() to execute,\n// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.\ntype FilesNeedSyncImp struct {\n\t*imptest.CallableController[FilesNeedSyncImpReturn]\n\tcallable func(src, dst *fileops.FileInfo) bool\n}\n\n// NewFilesNeedSyncImp creates a new wrapper for testing the callable function.\n// Pass the function to test and a testing.TB to enable assertion failures.\n//\n// Example:\n//\n//\twrapper := NewFilesNeedSyncImp(t, myFunction)\n//\twrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)\nfunc NewFilesNeedSyncImp(t testing.TB, callable func(src, dst *fileops.FileInfo) bool) *FilesNeedSyncImp {\n\treturn \u0026FilesNeedSyncImp{\n\t\tCallableController: imptest.NewCallableController[FilesNeedSyncImpReturn](t),\n\t\tcallable:           callable,\n\t}\n}\n\n// ExpectPanicWith asserts the callable panicked with a value matching the expectation.\n// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if the callable returned normally or panicked with a different value.\nfunc (s *FilesNeedSyncImp) ExpectPanicWith(expected any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Panicked != nil {\n\t\tok, msg := imptest.MatchValue(s.Panicked, expected)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"panic value: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to panic, but it returned\")\n}\n\n// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.\n// Fails the test if the values don't match exactly or if the callable panicked.\n// Uses == for comparison, so reference types must be the same instance.\nfunc (s *FilesNeedSyncImp) ExpectReturnedValuesAre(v1 bool) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tif s.Returned.Result0 != v1 {\n\t\t\ts.T.Fatalf(\"expected return value 0 to be %v, got %v\", v1, s.Returned.Result0)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// ExpectReturnedValuesShould asserts return values match the given matchers.\n// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if any matcher fails or if the callable panicked.\nfunc (s *FilesNeedSyncImp) ExpectReturnedValuesShould(v1 any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tvar ok bool\n\t\tvar msg string\n\t\tok, msg = imptest.MatchValue(s.Returned.Result0, v1)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 0: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// GetResponse waits for and returns the callable's response.\n// Use this when you need to inspect the response without asserting specific values.\n// The response indicates whether the callable returned or panicked.\nfunc (s *FilesNeedSyncImp) GetResponse() *FilesNeedSyncImpResponse {\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\treturn \u0026FilesNeedSyncImpResponse{\n\t\t\tEventType: \"ReturnEvent\",\n\t\t\tReturnVal: s.Returned,\n\t\t}\n\t}\n\n\treturn \u0026FilesNeedSyncImpResponse{\n\t\tEventType: \"PanicEvent\",\n\t\tPanicVal:  s.Panicked,\n\t}\n}\n\n// Start begins execution of the callable in a goroutine with the provided arguments.\n// Returns the wrapper for method chaining with expectation methods.\n// Captures both normal returns and panics for verification.\n//\n// Example:\n//\n//\twrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)\nfunc (s *FilesNeedSyncImp) Start(src, dst *fileops.FileInfo) *FilesNeedSyncImp {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\ts.PanicChan \u003c- r\n\t\t\t}\n\t\t}()\n\n\t\tret0 := s.callable(src, dst)\n\t\ts.ReturnChan \u003c- FilesNeedSyncImpReturn{\n\t\t\tResult0: ret0,\n\t\t}\n\t}()\n\treturn s\n}\n\n// FilesNeedSyncImpResponse represents the response from the callable (either return or panic).\n// Check EventType to determine if the callable returned normally or panicked.\n// Use AsReturn() to get return values as a slice, or access PanicVal directly.\ntype FilesNeedSyncImpResponse struct {\n\tEventType string // \"return\" or \"panic\"\n\tReturnVal *FilesNeedSyncImpReturn\n\tPanicVal  any\n}\n\n// AsReturn converts the return values to a slice of any for generic processing.\n// Returns nil if the response was a panic or if there are no return values.\nfunc (r *FilesNeedSyncImpResponse) AsReturn() []any {\n\tif r.ReturnVal == nil {\n\t\treturn nil\n\t}\n\treturn []any{r.ReturnVal.Result0}\n}\n\n// Type returns the event type: \"return\" for normal returns, \"panic\" for panics.\nfunc (r *FilesNeedSyncImpResponse) Type() string {\n\treturn r.EventType\n}\n\n// FilesNeedSyncImpReturn holds the return values from the callable function.\n// Access individual return values via Result0, Result1, etc. fields.\ntype FilesNeedSyncImpReturn struct {\n\tResult0 bool\n}\n",
      "filename": "generated_FilesNeedSyncImp_test.go"
    },
    "fileops.ScanDirectory": {
      "signature": "63198fa99f54cdf14aec41144cdec5c88d4c3f20609cf3636a3060e6bc1a2b2d",
      "content": "// Code generated by impgen. DO NOT EDIT.\n\npackage fileops_test\n\nimport (\n\tfileops \"github.com/joe/copy-files/pkg/fileops\"\n\t\"github.com/toejough/imptest/imptest\"\n\t\"testing\"\n)\n\n// ScanDirectoryImp wraps a callable function for testing.\n// Create with NewScanDirectoryImp(t, yourFunction), call Start() to execute,\n// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.\ntype ScanDirectoryImp struct {\n\t*imptest.CallableController[ScanDirectoryImpReturn]\n\tcallable func(rootPath string) (map[string]*fileops.FileInfo, error)\n}\n\n// NewScanDirectoryImp creates a new wrapper for testing the callable function.\n// Pass the function to test and a testing.TB to enable assertion failures.\n//\n// Example:\n//\n//\twrapper := NewScanDirectoryImp(t, myFunction)\n//\twrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)\nfunc NewScanDirectoryImp(t testing.TB, callable func(rootPath string) (map[string]*fileops.FileInfo, error)) *ScanDirectoryImp {\n\treturn \u0026ScanDirectoryImp{\n\t\tCallableController: imptest.NewCallableController[ScanDirectoryImpReturn](t),\n\t\tcallable:           callable,\n\t}\n}\n\n// ExpectPanicWith asserts the callable panicked with a value matching the expectation.\n// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if the callable returned normally or panicked with a different value.\nfunc (s *ScanDirectoryImp) ExpectPanicWith(expected any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Panicked != nil {\n\t\tok, msg := imptest.MatchValue(s.Panicked, expected)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"panic value: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to panic, but it returned\")\n}\n\n// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.\n// Fails the test if the values don't match exactly or if the callable panicked.\n// Uses == for comparison, so reference types must be the same instance.\nfunc (s *ScanDirectoryImp) ExpectReturnedValuesAre(v1 map[string]*fileops.FileInfo, v2 error) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tif !reflect.DeepEqual(s.Returned.Result0, v1) {\n\t\t\ts.T.Fatalf(\"expected return value 0 to be %v, got %v\", v1, s.Returned.Result0)\n\t\t}\n\t\tif s.Returned.Result1 != v2 {\n\t\t\ts.T.Fatalf(\"expected return value 1 to be %v, got %v\", v2, s.Returned.Result1)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// ExpectReturnedValuesShould asserts return values match the given matchers.\n// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.\n// Fails the test if any matcher fails or if the callable panicked.\nfunc (s *ScanDirectoryImp) ExpectReturnedValuesShould(v1 any, v2 any) {\n\ts.T.Helper()\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\tvar ok bool\n\t\tvar msg string\n\t\tok, msg = imptest.MatchValue(s.Returned.Result0, v1)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 0: %s\", msg)\n\t\t}\n\t\tok, msg = imptest.MatchValue(s.Returned.Result1, v2)\n\t\tif !ok {\n\t\t\ts.T.Fatalf(\"return value 1: %s\", msg)\n\t\t}\n\t\treturn\n\t}\n\n\ts.T.Fatalf(\"expected function to return, but it panicked with: %v\", s.Panicked)\n}\n\n// GetResponse waits for and returns the callable's response.\n// Use this when you need to inspect the response without asserting specific values.\n// The response indicates whether the callable returned or panicked.\nfunc (s *ScanDirectoryImp) GetResponse() *ScanDirectoryImpResponse {\n\ts.WaitForResponse()\n\n\tif s.Returned != nil {\n\t\treturn \u0026ScanDirectoryImpResponse{\n\t\t\tEventType: \"ReturnEvent\",\n\t\t\tReturnVal: s.Returned,\n\t\t}\n\t}\n\n\treturn \u0026ScanDirectoryImpResponse{\n\t\tEventType: \"PanicEvent\",\n\t\tPanicVal:  s.Panicked,\n\t}\n}\n\n// Start begins execution of the callable in a goroutine with the provided arguments.\n// Returns the wrapper for method chaining with expectation methods.\n// Captures both normal returns and panics for verification.\n//\n// Example:\n//\n//\twrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)\nfunc (s *ScanDirectoryImp) Start(rootPath string) *ScanDirectoryImp {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\ts.PanicChan \u003c- r\n\t\t\t}\n\t\t}()\n\n\t\tret0, ret1 := s.callable(rootPath)\n\t\ts.ReturnChan \u003c- ScanDirectoryImpReturn{\n\t\t\tResult0: ret0,\n\t\t\tResult1: ret1,\n\t\t}\n\t}()\n\treturn s\n}\n\n// ScanDirectoryImpResponse represents the response from the callable (either return or panic).\n// Check EventType to determine if the callable returned normally or panicked.\n// Use AsReturn() to get return values as a slice, or access PanicVal directly.\ntype ScanDirectoryImpResponse struct {\n\tEventType string // \"return\" or \"panic\"\n\tReturnVal *ScanDirectoryImpReturn\n\tPanicVal  any\n}\n\n// AsReturn converts the return values to a slice of any for generic processing.\n// Returns nil if the response was a panic or if there are no return values.\nfunc (r *ScanDirectoryImpResponse) AsReturn() []any {\n\tif r.ReturnVal == nil {\n\t\treturn nil\n\t}\n\treturn []any{r.ReturnVal.Result0, r.ReturnVal.Result1}\n}\n\n// Type returns the event type: \"return\" for normal returns, \"panic\" for panics.\nfunc (r *ScanDirectoryImpResponse) Type() string {\n\treturn r.EventType\n}\n\n// ScanDirectoryImpReturn holds the return values from the callable function.\n// Access individual return values via Result0, Result1, etc. fields.\ntype ScanDirectoryImpReturn struct {\n\tResult0 map[string]*fileops.FileInfo\n\tResult1 error\n}\n",
      "filename": "generated_ScanDirectoryImp_test.go"
    }
  }
}
